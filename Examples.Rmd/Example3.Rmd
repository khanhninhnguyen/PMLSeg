---
output: github_document
---

<!-- Example3.md is generated from Example3.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  fig.width=6, fig.height=3
)
options(tibble.print_min = 5, tibble.print_max = 5)
```

## Example 3: time series with clusters of CPs

In real data, clusters of CPs can occur in a short period of time or can be due to noise spikes.
In many applications, we don't want to keep such clusters with short segments.
We have included a screening function which removes clusters or reduces them to single CPs, depending on the significance of the change in mean before/after each cluster. If the change is significant the cluster is replaced by a single CP, otherwise all the CPs in that cluster are removed.

### 1. Simulate a time series with 2 clusters

```{r}
rm(list=ls(all=TRUE))
library(PMLseg)

# define simulation function
simulate_time_series <- function(cp_ind, segmt_mean, noise_stdev, length_series) {
  time_series <- rep(0, length_series)
  jump_indices <- c(1, cp_ind+1, length_series + 1)
  offsets <- c(0, diff(segmt_mean))

  changes <- rep(0, length_series)
  changes[jump_indices[-length(jump_indices)]] <- offsets
  changes[1] <- segmt_mean[1]

  time_series <- cumsum(changes)
  noise <- rnorm(n = length_series, mean = 0, sd = noise_stdev)
  time_series <- time_series + noise

  return(time_series)
}

# specify the simulation parameters
n <- 1000                                       # length of time series
cp_ind <- c(10, 200, 210, 580, 590, 600, 990)   # 2 clusters of CPs + one short segment at the begining and one at the end
segmt_mean <- c(0, -1, 5, 1, -5, 5, 2, 0)       # mean of segments
noise_stdev <- 1                                # noise std dev (identical for all months)
set.seed(1)                                     # initialise random generator

# create a data frame of time series with 2 columns: date, signal
mydate <- seq.Date(from = as.Date("2010-01-01"), to = as.Date("2010-01-01")+(n-1), by = "day")
mysignal <- simulate_time_series(cp_ind, segmt_mean, noise_stdev, n)
df <- data.frame(date = mydate, signal = mysignal)

CP_date <- mydate[cp_ind]                       # dates of CP

# plot signal and position of change-points
plot(df$date, df$signal, type = "l", col = "gray", xlab = "date", ylab = "signal", main="Simulated time series")
abline(v = CP_date, col = "red", lty = 2)
```

### 2. Segmentation

Run the segmentation without the functional part:

```{r}
seg = Segmentation(OneSeries = df, 
                   FunctPart = FALSE)

seg$Tmu
```

### 3. Visualization of the time series with segmentation results superposed

```{r}
PlotSeg(OneSeries = df, 
        SegRes = seg, 
        FunctPart = FALSE)
```

Note that the segmentation is able to detect all CPs, even those close to the beginning and end of the time series.

### 4. Cluster screening 

We want to remove the segments smaller than 80 days, either isolated or in clusters.

```{r}
cluster_max_dist <- 80             # max distance between CPs in a cluster
screening <- Cluster_screening(Tmu = seg$Tmu, MaxDist = cluster_max_dist)
screening
```
The Cluster_screening function returns information to update the segmentation dataframe.

Now, update the segmentation parameters

```{r}
seg_updated <- UpdatedParametersForFixedCP(OneSeries = df, ResScreening = screening, FunctPart=FALSE)
seg_updated
```

Plot the time series with the updated segmentation information and mask the data removed by the screening (`RemoveData` option).

```{r}
PlotSeg(OneSeries = df, SegRes = seg_updated, FunctPart = FALSE, RemoveData = screening$RemoveData)
```

Note that the data in the clusters are only masked in the plot. They are still contained in the time series dataframe. 
It is recommended to replace them with NA values in `df$signal`.
