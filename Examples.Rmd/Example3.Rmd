---
output: github_document
---

<!-- Example3.md is generated from Example3.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
options(tibble.print_min = 5, tibble.print_max = 5)
```

## Example 3: time series with clusters of CPs

In real data, clusters of CPs can occur in a short period of time or can be due to noise spikes.
In many applications, we don't want to keep such clusters with short segments.
We have included a screening function which replaces a clusters by one single CP if the change in mean before vs. after is significant, or removes all the CPs if it is not significant.

### 1. Simulate a time series with 2 clusters

```{r}
rm(list=ls(all=TRUE))
library(PMLseg)

# define simulation function
simulate_time_series <- function(cp_ind, segmt_mean, noise_stdev, length_series) {
  time_series <- rep(0, length_series)
  jump_indices <- c(1, cp_ind+1, length_series + 1)
  offsets <- c(0, diff(segmt_mean))

  changes <- rep(0, length_series)
  changes[jump_indices[-length(jump_indices)]] <- offsets
  changes[1] <- segmt_mean[1]

  time_series <- cumsum(changes)
  noise <- rnorm(n = length_series, mean = 0, sd = noise_stdev)
  time_series <- time_series + noise

  return(time_series)
}

# specify the simulation parameters
n = 1000                                       # length of time series
cp_ind <- c(10, 200, 210, 580, 590, 600, 990)  # 2 clusters of CPs + one short segment at the begining and one at the end => 7 CPs
segmt_mean <- c(0, -1, 5, 1, -5, 5, 2, 0)      # mean of segments
noise_stdev = 1                                # noise std dev (identical for all months)
set.seed(1)                                    # initialise random generator

# let's assume the true CPs are at index 200 and 600
true_cp_ind <- c(200, 600)                     # only 2 true CPs 

# create a data frame of time series with 2 columns: date, signal
mydate <- seq.Date(from = as.Date("2010-01-01"), to = as.Date("2010-01-01")+(n-1), by = "day")
mysignal <- simulate_time_series(cp_ind, segmt_mean, noise_stdev, n)
df = data.frame(date = mydate, signal = mysignal)

# plot signal and position of change-points (red dashed line)
plot(df$date, df$signal, type = "l",xlab ="Date",ylab="signal")
abline(v = mydate[cp_ind], col = "grey", lty = 2)
abline(v = mydate[true_cp_ind], col = "red", lty = 2)
```

### 2. Segmentation

Run the segmentation with default parameters and no functional:

```{r}
seg = Segmentation(OneSeries = df, 
                   FunctPart = FALSE)
str(seg)

seg$Tmu
```

### 3. Visualization of the time series with segmentation results superposed

```{r}
PlotSeg(OneSeries = df, 
        SegRes = seg, 
        FunctPart = FALSE)
```

Note that the segmentation is able to detect all CPs, even those close to the beginning and end of the time series.

### 4. Cluster screening 

We want to remove the segments smaller than 80 days, either isolated or in clusters.

```{r}
cluster_max_dist = 80             # max distance between CPs in a cluster
screening = Cluster_screening(Tmu = seg$Tmu, MaxDist = cluster_max_dist)
screening
```
The Cluster_screening function returns information to update the segmentation dataframe.

Now, update the segmentation parameters

```{r}
seg_updated = UpdatedParametersForFixedCP(OneSeries = df, ResScreening = screening, FunctPart=FALSE)
seg_updated
```

Plot the time series with the updated segmentation and RemoveData information

```{r}
PlotSeg(OneSeries = df, SegRes = seg_updated, FunctPart = FALSE, RemoveData = screening$RemoveData)
```

Note that the data in the clusters are hidden by the Plot function with the RemoveData option, but they are still in the time series dataframe. 
To actually remove the data, do the following:

```{r}
# Cleanup the time series dataframe
df_screened <- df
for (i in 1:(nrow(screening$RemoveData))) {
    df_screened$signal[screening$RemoveData$begin[i]:screening$RemoveData$end[i]] = NA
}
```

### 5. Validation of detected change-points with metadata
```{r}
true_cp_df = data.frame(date = df$date[true_cp_ind], type = rep("True", (length(true_cp_ind))))
valid_max_dist = 10               # max distance between CP and metadata for the validation
valid = Validation(OneSeries = df, Tmu = seg_updated$Tmu, MaxDist = valid_max_dist, Metadata = true_cp_df)
valid
PlotSeg(OneSeries = df_screened, SegRes = seg_updated, FunctPart = FALSE, Metadata = true_cp_df, Validated_CP_Meta = valid)
```
