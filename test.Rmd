---
title: "Test PMLSeg"
author: "Ninh"
date: "2024-08-09"
output: beamer_presentation
font-family: 'Helvetica'
fontsize: 9pt
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  out.width = "100%"
)
options(tibble.print_min = 5, tibble.print_max = 5)
```

## Intro 

This document present result of several test of the PMLSeg package consisting:

- Test of the `Segmentation` function in case  with/ without offsets for the following examples : 

  + Ex1 : zero mean + IID noise
  
  + Ex2 : periodic mean + IID noise 
  
  + Ex3 : periodic mean + monthly variance 
  
- Test of other functions such as: 

  + `PlotSeg` to visualize segmentation results 
  
  + `Cluster_screening` to detect the group of close change-points (ussualy due to the outliers) and check if it is needed to keep or remove the cluster. 
  
  + `Validation` to validate the detected changepoints with the help of metadata.

## Generate example data to test 

Ex1 time series 

\footnotesize
```{r ex1, size = "small", echo = TRUE, fig.width = 6, fig.height = 3}
set.seed(1)
length_series = 1000
df1 = data.frame(date = seq.Date(from = as.Date("2010-01-01"),
                                to = as.Date("2010-01-01")+(length_series-1), 
                                by = "day"),  
                signal = rnorm(n = length_series, mean = 0, sd = 1))

plot(df1$date, df1$signal, type = "l")
head(df1, 3)
```

## Generate example data to test 

Ex2 time series : add the functional with 4 Fourier series with coefficient = 1
\footnotesize
```{r ex2, echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
library(dplyr)

T <- 365.25
df2 <- df1 %>%
  mutate(t = as.numeric(date - date[1])+1,
  f = rowSums(sapply(1:4, function(i) 0.5*cos(i*t*(2*pi)/T) + 0.5*sin(i*t*(2*pi)/T))),
  signal = signal + f)

head(df2, 3)
plot(df2$date, df2$f, type = "l")
```

## Generate example data to test 

Ex3 time series : add the functional with 4 Fourier series with coefficient = 1
\footnotesize
```{r ex3, echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
std = c(1, 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.6, 1.5, 1.4, 1.3)

df3 <- df1 %>% 
  mutate(sd = std[as.numeric(format(date, "%m"))],
         signal = signal * sd ) %>%
  mutate(signal = signal + df2$f)

head(df3, 3)
plot(df3$date, df3$signal, type = "l")
```

## Generate example data to test 

Harmmonize format of 3 dataframes to test: 
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
df2 <- df2 %>% select(date, signal)
df3 <- df3 %>% select(date, signal)

names(df1)
names(df2)
names(df3)
```
## Premilinary setting

Generate different offset series to add into the original series (which is without change-point) :
\footnotesize

```{r jump, echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}

# Function to generate jump series
generate_jump_series <- function(jump_indices, jump_amp, length_series) {
  jump_series <- rep(0, length_series)
  jump_indices <- c(1, jump_indices, length_series + 1)
  
  changes <- rep(0, length_series)
  changes[jump_indices[-length(jump_indices)]] <- jump_amp
  
  jump_series <- cumsum(changes)
  
  return(jump_series)
}
# No cluster (group of close changepoint within 80 days
jump_ind1 <- c(200, 600)
jump_amp1 <- c(0, 1, 1)
# One cluster formed by the second and third changepoints, which need to be keep 
jump_ind2 <- c(200, 600, 640)
jump_amp2 <- c(0, 1, -2, 1)
# One cluster formed by the second and third changepoints, which need to be remove 
jump_amp3 <- c(0, 1, -2, 2)
```

## Premilinary setting
\footnotesize

```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
# Generate jump series
jump_series1 <- generate_jump_series(jump_ind1, jump_amp1, length_series)
jump_series2 <- generate_jump_series(jump_ind2, jump_amp2, length_series)
jump_series3 <- generate_jump_series(jump_ind2, jump_amp3, length_series)
plot(jump_series1, type = "l", ylim = c(-2,3))
lines(jump_series2, col = "red")
lines(jump_series3, col = "blue")
```

## Test the `Segmentation` function

When series is homogeneous 
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
library(PMLseg)
# Ex1 
seg1a = Segmentation(OneSeries = df1, FunctPart = FALSE)
str(seg1a)
seg1a$Tmu
```
\normalsize 
No change-point is detected show in `Tmu` dataframe, which listed all segments of the series. The mean is close to 0. Additionally, the result is a list includes not only `Tmu` dataframe but also the fitted functional part `FitF` (which is not fitted by setting FunctPart = FALSE), coefficient of functional element `CoeefF`, monthly variance `MonthVar` and the Sum Square of Residual `SSR`. 

## Test the `Segmentation` function

When series is homogeneous for example 2 and 3
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
# Ex2 
seg2a = Segmentation(OneSeries = df2, FunctPart = TRUE)
seg2a$Tmu
# Ex3 
seg3a = Segmentation(OneSeries = df3, FunctPart = TRUE)
seg3a$Tmu
```
No changepoint is detected neither in these two example. 

## Test the `Segmentation` function

When we add the jump series in the series 
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
# Ex1 
df1b <- df1 %>% mutate(signal = signal + jump_series1)
seg1b = Segmentation(OneSeries = df1b, FunctPart = FALSE)
seg1b$Tmu

# Ex2 
df2b <- df2 %>% mutate(signal = signal + jump_series1)
seg2b = Segmentation(OneSeries = df2b, FunctPart = TRUE)
seg2b$Tmu

# Ex3 
df3b <- df3 %>% mutate(signal = signal + jump_series1)
seg3b = Segmentation(OneSeries = df3b, FunctPart = TRUE)
seg3b$Tmu
```

## Test the `Segmentation` function

When we add other jump series in the most complicated series (Ex3) 
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}

df3c <- df3 %>% mutate(signal = signal + jump_series2)
seg3c = Segmentation(OneSeries = df3c, FunctPart = TRUE)
seg3c$Tmu

df3d <- df3 %>% mutate(signal = signal + jump_series3)
seg3d = Segmentation(OneSeries = df3d, FunctPart = TRUE)
seg3d$Tmu
```
## Test the `PlotSeg` function

Visualize the segmentation result of example 1
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
PlotSeg(OneSeries = df1, SegRes = seg1b, FunctPart = FALSE)
```
## Test the `PlotSeg` function

Visualize the segmentation result of example 2
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
PlotSeg(OneSeries = df2, SegRes = seg2b, FunctPart = FALSE)
```

## Test the `PlotSeg` function

Visualize the segmentation result of example 3
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
PlotSeg(OneSeries = df3c, SegRes = seg3c, FunctPart = FALSE)
```
## Test the `PlotSeg` function

Visualize the segmentation result of example 3
\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
PlotSeg(OneSeries = df3d, SegRes = seg3d, FunctPart = FALSE)
```

## Test the `PlotSeg` function

\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
PlotSeg(OneSeries = df3d, SegRes = seg3d, FunctPart = FALSE)
```

## Test the `Cluster_screening` function

Segmentation sometime detects very short segment like in example 3c, 3d. When it is too close and after cluster, the change in mean is not significant, we will remove such kind of cluster. If it is significant, we will replace a cluster by the middle point and remove the data inside the cluster. 

\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
# Validate the segmentation result wrt metadata 
screening1 = Cluster_screening(Tmu = seg3c$Tmu,
                              MaxDist = 80)
screening1

screening2 = Cluster_screening(Tmu = seg3d$Tmu,
                              MaxDist = 80)
screening2
```

## Test the `UpdatedParametersForFixedCP` function

When the screening say it is needed to replace the changepoint, we need to update the `Tmu` dataframe. 

\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
# Validate the segmentation result wrt metadata 
seg_upd = UpdatedParametersForFixedCP(OneSeries = df, 
                                      ResScreening = screening, 
                                      FunctPart = FALSE)
seg_upd
```

## Test the `UpdatedParametersForFixedCP` function

Visualize the time series after the update segmentation 

\footnotesize
```{r , echo = TRUE, message=FALSE, fig.width = 6, fig.height = 3}
PlotSeg(OneSeries = df3d, 
        SegRes = seg_upd, 
        FunctPart = FALSE)
```



